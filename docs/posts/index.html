<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Ryosuke Yoneda</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Ryosuke Yoneda">
<meta name="author" content="">
<link rel="canonical" href="https://yonesuke.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yonesuke.github.io/favicon_io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yonesuke.github.io/favicon_io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yonesuke.github.io/favicon_io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yonesuke.github.io/favicon_io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yonesuke.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://yonesuke.github.io/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://yonesuke.github.io/css/theoremproof.css">
<meta property="og:title" content="Posts" />
<meta property="og:description" content="Ryosuke Yoneda&#39;s Homepage" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yonesuke.github.io/posts/" /><meta property="og:image" content="https://yonesuke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/><meta property="og:site_name" content="Ryosuke Yoneda" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://yonesuke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/>

<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="Ryosuke Yoneda&#39;s Homepage"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://yonesuke.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yonesuke.github.io" accesskey="h" title="Ryosuke Yoneda&#39;s Homepage (Alt + H)">
                <img src="https://yonesuke.github.io/favicon_io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Ryosuke Yoneda&#39;s Homepage</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yonesuke.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://yonesuke.github.io/research" title="Research">
                    <span>Research</span>
                </a>
            </li>
            <li>
                <a href="https://yonesuke.github.io/teaching" title="Teaching">
                    <span>Teaching</span>
                </a>
            </li>
            <li>
                <a href="https://yonesuke.github.io/posts" title="Posts">
                    <span class="active">Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://yonesuke.github.io">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>オルンシュタイン-ウーレンベック過程<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>オルンシュタイン-ウーレンベック過程の基本的な性質を振り返り、 python(diffrax)で数値計算を行う。
オルンシュタイン-ウーレンベック過程 オルンシュタインウーレンベック過程はもとをたどればブラウン運動を記述するランジュバン方程式になるだろう。 ランジュバン方程式は速度に比例する摩擦力と外部からの揺動力を受ける粒子の速度を記述する方程式である。 これを確率微分方程式の形で書き下したものがオルンシュタイン-ウーレンベック過程である。
$$ dx_t = \theta(\mu - x_t)dt &#43; \sigma dW_t $$
解く 定数変化法を利用する。$x_{t}e^{\theta t}$を微分すると、 $$ d(x_{t}e^{\theta t})=e^{\theta t}dx_t&#43;\theta e^{\theta t}x_t dt =\theta\mu e^{\theta t}dt&#43;\sigma e^{\theta t}dW_t $$ である。これを積分すると、 $$ x_{t}e^{\theta t}=x_0&#43;\mu(e^{\theta t}-1)&#43;\sigma\int_0^t e^{\theta s}dW_s $$ である。両辺を$e^{\theta t}$で割ると、 $$ x_t = x_0 e^{-\theta t} &#43; \mu (1 - e^{-\theta t})&#43;\sigma\int_0^t e^{\theta (s-t)}dW_s $$ が得られる。
この解の期待値と共分散は次のようになる。 $$ \begin{align*} &amp;\mathbb{E}[x_t] = x_0 e^{-\theta t} &#43; \mu (1 - e^{-\theta t}),\\ &amp;\mathrm{cov}(x_t,x_s) = \frac{\sigma^2}{2\theta}e^{-\theta(t&#43;s)}(e^{2\theta\min(t,s)}-1) \end{align*} $$ 特に分散は$t=s$とすることで$\sigma^{2}(1-e^{-2\theta t})/2\theta$が得られる。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-22 10:08:44 +0900 JST'>July 22, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;427 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to オルンシュタイン-ウーレンベック過程" href="https://yonesuke.github.io/posts/ou_process/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>ベンフォードの法則
    </h2>
  </header>
  <div class="entry-content">
    <p>ベンフォードの法則は「自然界に現れる多くの数値の最初の桁の値はある特定の分布に従う」ことを指す法則である。 ふと出くわして非常に面白かったのでまとめておく。
ベンフォードの法則 ベンフォードの法則は以下のように定義される。 自然界に現れる多くの数値の最初の桁の値は、一様分布ではなく、次のような分布に従う。 $$ P(d) = \log_{10}\left(1 &#43; \frac{1}{d}\right) $$ ただし、$d=1,2,\dots,9$である。 もちろんこれは常に正しいわけではなく、経験的にそうなっている、というものである。 ただ、以下でみるようにべき的なふるまいを見せるデータに対してはベンフォードの法則が成り立つことが示せる。 この意味で、むしろ自然界にはべき的なふるまいをするデータがたくさんあることはよく知られているので、 ベンフォードの法則が成り立つようなデータが多くあることは自然なのかもしれない。
指数関数の場合 べき乗則に従うようなデータに対しては、ベンフォードの法則が成り立つことが簡単に示せる。 簡単に$n$番目のデータが$b^n$の場合を考える。
$b^n$の最初の桁の値は$\log_{10}$をとった際の小数点によって決まる。 例えば、$b^{3}$の先頭が5ならば、$\log_{10} 5\leq 3\log_{10}b\ (\bmod 1)&lt;\log_{10} 6$である。 よって、$n\log_{10} b \ (\bmod 1)$が$[0, 1]$区間で従う分布がそのまま$b^n$の一桁目の分布に従う。 $\log_{10} b$が無理数ならば、ワイルの均等分布定理から一様分布に従うことがわかる。 すなわち、十分に大きな$n$において、先頭の桁が$d$となる確率は $$ \log_{10}(d&#43;1) - \log_{10} d = \log_{10}\left(1 &#43; \frac{1}{d}\right) $$ とわかる。これはベンフォードの法則の法則に他ならない。
具体例 フィボナッチ数列 フィボナッチ数列は$a_{0}=a_{1}=1$として、一般の$n\geq2$について $$ a_{n}=a_{n-1} &#43; a_{n-2} $$ で定められる数列$\{a_{n}\}$を指す。 pythonでこの数列を実装するには再帰を利用する必要があるが、メモ化を行うことで高速化することができる。pythonでは幸いfunctools.cacheが提供されているので簡単に実装ができる。
1 2 3 4 5 6 7 from functools import cache @cache def fib(n): if n == 0 or n == 1: return 1 return fib(n-1) &#43; fib(n-2) この関数を用いて、フィボナッチ数列の最初の桁の値の分布を調べてみよう。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-07-01 09:40:29 +0900 JST'>July 1, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;292 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to ベンフォードの法則" href="https://yonesuke.github.io/posts/benford/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>決定木を1から実装する
    </h2>
  </header>
  <div class="entry-content">
    <p>決定木って名前はよく聞くしscikit-learnで簡単に使えてしまうけど、中身を詳しく知っているわけではなかったのできちんと実装してみることにする。 from scratchでの実装にはこの記事が非常に参考になった。
https://towardsdatascience.com/implementing-a-decision-tree-from-scratch-f5358ff9c4bb https://darden.hatenablog.com/entry/2016/12/15/222447 決定木 まず決定木の仕組みについて説明する。 とは言っても懇切丁寧に説明している記事はほかにいくらでもあるので、ここではざっくりとした説明に留める。
アルゴリズム 決定木における分類問題においては分類を行いたい対象に対する特徴量がn_features個与えられており、各特徴量は数で表現されるとする。
例えば、sklearn内に格納されているirisデータセットには4個の特徴量が用意されている。具体的には、sepal length, sepal width, petal length, petal widthであり、いずれも単位はcmの数になっている。 このとき、決定木は与えられた特徴量たちに対して「特徴量Aは$x$より小さいか？」という質問を行う。この質問に対する答えがYesならば、次に「特徴量Bは$y$より小さいか？」という質問を、答えがNoならば、「特徴量Cは$z$より小さいか？」という質問を行う。 こういった質問を次々に行っていき、最後に「前の質問の答えがYesならば分類クラスはPである」といった具合に分類を行う。これが決定木の一つの大きな流れである。
質問によって分岐が起きていくので、最初の質問を根とする木とみなすことができる。 この木のもとでは各質問は木のノードと捉えられ、また分岐の果てに分類問題の答えを出力する所は葉とみなすことができる。
学習 上で説明した決定木アルゴリズムにおいて、各ノードに配置する「特徴量Aは$x$より小さいか？」という質問を作成する必要がある。これを学習データをもとに決定していくCARTアルゴリズムを紹介する。
学習の流れは各ノードを根から順に決定していく流れとなるので、再帰的な構造を持つ。 学習データが質問を経てあるノードに到着した段階でn_samples個になったとしよう。 このとき、学習データがそれぞれ持つ分類クラスが質問を通して最も別れるような質問が最適な質問であると考える。明日晴れるか雨が降るかを知りたいときに、質問にYesと答えれば必ず晴れ、Noと答えれば必ず雨、ということが分かれば、これは最適な質問である、ということである。 これを定量的に評価する方法として、情報利得を用いることを考える。 n_samples個の学習データのそれぞれのクラスが格納された$y\in\mathbb{R}^{n_\mathrm{samples}}$に対して、クラスの揃い具合を表す情報量$f\colon\mathbb{R}^{N}\to\mathbb{R}$があったとしよう。 この指標は値が小さいほど学習データの分類クラスは揃っていて、値が大きいほどに学習データの分類クラスは全くもってばらけている状況を想定する。 ある質問を通して、n_left個の学習データがYesと、n_right個の学習データがNoと答えたとしよう。また、これに応じて分類クラス$y$は$y_{\mathrm{left}}$と$y_{\mathrm{right}}$に分けられるとする。 学習データが入力された段階では、情報量は$f(y)$である。 また、質問にYesと答えたときの情報量は$f(y_{\mathrm{left}})$、Noと答えたときの情報量は$f(y_{\mathrm{right}})$となる。 確率的には質問に答えた後の情報量は$\frac{n_{\mathrm{left}}}{n_{\mathrm{samples}}}f(y_{\mathrm{left}}) &#43; \frac{n_{\mathrm{right}}}{n_{\mathrm{samples}}}f(y_{\mathrm{right}})$となる。よって、質問に答える前後で情報利得 $$ f(y) - \left(\frac{n_{\mathrm{left}}}{n_{\mathrm{samples}}}f(y_{\mathrm{left}}) &#43; \frac{n_{\mathrm{right}}}{n_{\mathrm{samples}}}f(y_{\mathrm{right}})\right) $$ が最大となるような質問が最適である、と考える。 具体的な実装においては、各ノードに対して学習データを入力するたびごとに、まず特徴量を一つ選ぶ。学習データにわたってこの特徴量の値を閾値として情報利得を計算する。これをすべての特徴量と閾値に対して行い、最大の情報利得を取る特徴量と閾値でもってそのノードの質問を確定する、 という流れを取る。
分類クラスの揃い具合を表す代表的な指標として、エントロピーとジニ不純度が ある。sklearnはデフォルトでジニ不純度を指定するようである。
決定木の実装 はじめに、ノードの実装を行う。 各ノードは質問を決定する特徴量(のインデックス)self.featureとその閾値self.thresholdを持つ。 これにより定まる質問に対して答えがYesであれば左側の子ノードself.leftを、 Noであれば右側の子ノードselft.rightを参照するようにする。 ただし、葉ノードである場合には、その特徴量(のインデックス)を保管するようにする。
1 2 3 4 5 6 7 8 9 10 class Node: def __init__(self, feature=None, threshold=None, left=None, right=None, value=None): self....</p>
  </div>
  <footer class="entry-footer"><span title='2023-06-25 10:00:06 +0900 JST'>June 25, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;631 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to 決定木を1から実装する" href="https://yonesuke.github.io/posts/decision-tree/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>SHA-256に用いられる定数が微妙に合わない
    </h2>
  </header>
  <div class="entry-content">
    <p>ひょんなことからSHA-256を実装しようと思ったのだが、少し謎なところがあったのでまとめる。 何かわかる人がいたらコメントしてほしい。
SHA-256 SHA-256はハッシュ関数の一つで、任意の文字列を256ビットのハッシュ値を出力する関数である。 ハッシュ関数である以上そのアルゴリズムは複雑で、出力から元の文字列を取り出すことは困難である。 ただ、この関数自体はターミナルですぐに試すことができる。
1 2 3 4 echo -n &#39;hello, world&#39; | sha256sum &gt; 09ca7e4eaa6e8ae9c7d261167129184883644d07dfba7cbfbc4c8a2e08360d5b - echo -n &#39;hello, world!&#39; | sha256sum &gt; 68e656b251e67e8358bef8483ab0d51c6619f3e7a1a9f0e75838d41ff368f728 - もしくは、opensslを用いてもよい。
1 2 3 4 echo -n &#39;hello, world&#39; | openssl dgst -sha256 &gt; SHA2-256(stdin)= 09ca7e4eaa6e8ae9c7d261167129184883644d07dfba7cbfbc4c8a2e08360d5b echo -n &#39;hello, world!&#39; | openssl dgst -sha256 &gt; SHA2-256(stdin)= 68e656b251e67e8358bef8483ab0d51c6619f3e7a1a9f0e75838d41ff368f728 (当たり前だが)いずれも出力結果が同じであることが確認できる。また、文字列を少し変えるだけで全く異なった出力を得ることも見て取れる。
今回の記事ではそのアルゴリズム自体は扱わない。参考になる記事として以下を挙げておく。
https://en.wikipedia.org/wiki/SHA-2 Wikipedia https://blog.boot.dev/cryptography/how-sha-2-works-step-by-step-sha-256/ アルゴリズムの流れが詳しく書いてある https://sha256algorithm.com/ SHA-256が内部でどのような計算をするのかをアニメーションできれいに表示してくれる。一見の価値あり。こういったウェブサイトを作れるの尊敬する。 SHA-256のアルゴリズムの中に登場する定数 SHA-256のアルゴリズムの中には定数がいくつか登場する。 それは、ハッシュ値の初期値として設定されるもので、
first 32 bits of the fractional parts of the square roots of the first 8 primes 2....</p>
  </div>
  <footer class="entry-footer"><span title='2023-06-18 01:00:33 +0900 JST'>June 18, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;569 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to SHA-256に用いられる定数が微妙に合わない" href="https://yonesuke.github.io/posts/sha256-constants/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>単連結な被覆空間の存在
    </h2>
  </header>
  <div class="entry-content">
    <p>ホモロジーゼミの基本群パートの一つの山場である、被覆空間の分類定理がやってきました。 この定理を示すためには、単連結な被覆空間の存在証明が必要になります。
Theorem   弧状連結かつ局所弧状連結な位相空間$X,\tilde{X}$で、$\tilde{X}$は$X$の被覆空間とする。$\tilde{X}$が単連結になるための必要十分条件は$X$が半局所単連結であることである。 準備 はじめに、この証明に必要ないくつかの定義・定理を示します。
Definition    [半局所単連結] 位相空間$X$が半局所単連結であるとは、任意の$x\in X$に対して$x$の開近傍$U$が存在して、包含写像$i\colon U\hookrightarrow X$から誘導される基本群の準同型写像$i_{\ast}\colon \pi_{1}(U,x)\hookrightarrow \pi_{1}(X,x)$が自明になることである。 Theorem   $O$を$S$における1つの位相とする。$M$が$O$の基底であることと、任意の$A\in O$と任意の$x\in A$に対して、 $$ x\in W,\quad W\subset A $$ となる$W\in M$が存在することは同値である。 Theorem   空でない集合$S$について、$B(S)$の部分集合$M$が$O(M)$の基底であることは次の2つと同値である。
任意の$x\in S$に対してある$W\in M$が存在して$x\in W$となる。 任意の$W_{1},W_{2}\in M$で$W_{1}\cap W_{2}\ne \emptyset$であるとき、任意の$x\in W_{1}\cap W_{2}$に対して、ある$W\subset W_{1} \cap W_{2}$が存在して$x\in W$なる$W\in M$が存在する。 証明は位相の基底を参照してください。
基底を用いた連続性の特徴づけに関する次の定理があります。
Theorem   位相空間$X$から$Y$への写像$f$を考え、$Y$の位相の基底を$M_{Y}$とする。$f$が連続であることと任意の開基底$W\in M_{Y}$に対して$f^{-1}(W)\subset X$が開集合となることは同値である。 Proof: $f$が連続であるとき、$Y$の任意の開集合$U$に対して、$f^{-1}(U)$が開集合であることは明らかである。$U$を$M_{Y}$の基底とすると、$f^{-1}(U)$は$X$の開集合であるから示された。 逆に任意の開基底$W\in M_{Y}$に対して$f^{-1}(W)$が開集合であるとする。このとき、$Y$の任意の開集合$U$に対して、ある開基底$W_{\lambda}\in M_{Y}$が存在して、$U=\bigcup_{\lambda}W_{\lambda}$となる。 $f^{-1}(U)=\bigcup_{\lambda}f^{-1}(W_{\lambda})$であり、各$\lambda$について$f^{-1}(W_{\lambda})$は開集合となるので$f^{-1}(U)$は開集合となるので、$f$は連続である。 最後にliftにまたがる定理を2つ紹介します。path$\tilde{f}$が$f$のliftであるとは、$p\circ\tilde{f}=f$が成り立つことです。
Theorem    [path lifting property] $p\colon \tilde{X}\to X$を被覆空間とする。path$f\colon I\to X$について、始点$f(0)=x_{0}$のlift$\tilde{x}_ {0}$に対して、$\tilde{x}_{0}$を始点とする、$f$の唯一のlift $\tilde{f}\colon I\to \tilde{X}$が定まる。 Theorem   被覆空間$p\colon(\tilde{X}, \tilde{x}_ {0})\to (X,x_{0})$から誘導される写像 $$ p_{\ast}\colon \pi_{1}(\tilde{X}, \tilde{x}_ {0})\to\pi _ {1}(X, x_ {0});\quad [f]\mapsto [p\circ f] $$ は単射である。また、$\pi _ {1}(X, x_ {0})$の部分群である$p_{\ast}(\pi_{1}(\tilde{X}, \tilde{x}_ {0}))$の元は$x_{0}$を起点とするloopであって、そのliftが$\tilde{X}$上$\tilde{x}_{0}$を起点とするloopになる、ようなもののhomotopy類で表される。 証明 はじめに、必要条件を示します。 すなわち、$X$が単連結な被覆空間を持つとき、$X$が半局所単連結であることを示します。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-17 22:17:24 +0900 JST'>February 17, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;438 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to 単連結な被覆空間の存在" href="https://yonesuke.github.io/posts/existence_of_simply_connected_covering_space/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>位相の基底
    </h2>
  </header>
  <div class="entry-content">
    <p>ホモロジーゼミの中で位相の基底に関する議論が出てきたのでそれについてまとめます。 この記事は大部分が松坂の集合位相入門によっています。
定義 位相の生成 考える空間を$S$とし、その部分集合全体を集めた集合を$B(S)$で定めます。 $B(S)$の任意の部分集合$M$に対して$O(M)$を$O\supset M$であるような任意の位相に対する下限(すなわちそのような位相たちの共通部分)で定めます。
$O(M)$が具体的にどのような$S$の部分集合で表現されるかを決めるのが次の定理です。
Theorem   $M$を$B(S)$の任意の部分集合とする。このとき、 $$ O(M)=\left\{\bigcup_{\lambda\in\Lambda} B_{\lambda} \mathrel{}\middle|\mathrel{} B_{\lambda}\in M_{0}\right\} $$ である。ただし、 $$ M_{0}=\left\{ \bigcap_{i\in I} A_{i} \mathrel{}\middle|\mathrel{} A_{i}\in M, \# I&lt;\infty\right\} $$ である。 ここで、$\#I=0$であれば$\bigcap_{i\in I}A_{i}=S$で定めます。積の単位元を全体にしているようなものです。
位相の基底 Definition    [位相の基底] $M$が位相$O$の部分集合で$O$の任意の元$A$が $$ A=\bigcup_{\lambda\in\Lambda} W_{\lambda},\quad W_{\lambda}\in M $$ と表されるとき、$M$は$O$の基底であるという。 すなわち、任意の開集合が$M$の元を用いて展開できる、という意味で基底になっている、ということです。
性質 Theorem   $O$を$S$における1つの位相とする。$M$が$O$の基底であることと、任意の$A\in O$と任意の$x\in A$に対して、 $$ x\in W,\quad W\subset A $$ となる$W\in M$が存在することは同値である。 Proof: $M$が$O$の基底であるとき、$A$を$O$の任意の元とすると、基底の定義からある$W_{\lambda}\in M$が存在して、 $$ A=\bigcup_{\lambda\in\Lambda} W_{\lambda} $$ が成り立つ。このとき、$x\in A$なので、ある$\lambda^{\ast}\in \Lambda$が存在して$x\in W_{\lambda^{\ast}}$となるので示される。 逆に任意の$A\in O$と任意の$x\in A$に対して$x\in W_{x},W_{x}\subset A$なる$W_{x}\in M$が存在するとき、 $$ A=\bigcup_{x\in A}\{x\}=\bigcup_{x\in A} W_{x} $$ となるのでたしかに$M$は$O$の基底である。 Theorem   空でない集合$S$について、$B(S)$の部分集合$M$が$O(M)$の基底であることは次の2つと同値である。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-17 14:32:22 +0900 JST'>February 17, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;156 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to 位相の基底" href="https://yonesuke.github.io/posts/topology_basis/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>連結と局所連結、弧状連結と局所弧状連結について<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>ホモロジーゼミの中で連結性に関する議論が何度も出てくるのでその違いについていくらかまとめておきます。
定義 はじめに連結の定義を述べる。直感的に想像するような&#34;連結&#34;からかけ離れているように思われる。
Definition    [連結] 位相空間$X$が連結であるとは、同時に開かつ閉になる部分集合が$X$自身と空集合以外に存在しないことをいう。 連結であることの定義は若干直感的に理解するのが難しい。連結でない空間の特徴づけの一つにわかりやすいものがある。これは、“空でない2つの互いに素な開集合$A,B\subset X$によって$X=A\cup B$とかける&#34;ことによって連結でない空間を定義するものである。実際この性質を用いることもある。 位相空間$X$の部分集合$M$が連結であるとは、$M$に導入される相対位相に対して$M$が連結であることとして定義する。$M$が連結でないことは$X$の開集合を用いて上と同様に特徴づけられる。すなわち、空でない2つの開集合$A,B$が存在して、 $$ M\subset A\cup B, \quad A\cap B\cap M=\emptyset, \quad A\cap M\neq\emptyset, \quad B\cap M\neq\emptyset $$ となることである。 局所的に連結な空間を局所連結と呼ぶ。
Definition    [局所連結] 位相空間$X$の任意の$x\in X$の任意の開近傍$V$に対して、$x\in U\subset V$なる連結開集合$U$が存在するとき、$X$は局所連結であるという。 局所連結は局所的なものを見るので連結であれば局所連結であるように思われるがそうではない。これは後で反例を見る。
次に弧状連結の定義を見る。むしろ弧状連結のほうが&#34;連結&#34;らしさを感じる。
Definition    [弧状連結] 位相空間$X$が弧状連結であるとは、任意の2点$x,y\in X$に対してある連続写像$f\colon [0,1]\to X$が存在して、$f(0)=x,f(1)=y$が成り立つことをいう。 定義内に登場する$f$は$x$と$y$を結ぶ弧(path)である。 位相空間$X$の部分集合$M$が弧状連結であるとは、$M$に導入される相対位相に対して$M$が弧状連結であることとして定義する。 局所的に弧状連結な空間を局所弧状連結と呼ぶ。
Definition    [局所弧状連結] 位相空間$X$の任意の$x\in X$の任意の開近傍$V$に対して、$x\in U\subset V$なる弧状連結開集合$U$が存在するとき、$X$は局所弧状連結であるという。 局所弧状連結についても弧状連結と直接の関係がない。すなわち、弧状連結であれば局所弧状連結であるとは限らない。
性質 連結性に関する性質の中でも一番重要なのは、“連続写像を通して連結性が写る&#34;ことであろう。
Theorem   位相空間$X$は連結で連続写像$f\colon X\to Y$を通して位相空間$Y$へ写る。このとき、$f(X)$は$Y$の連結部分集合である。 Proof: $f(X)$が連結でないとすると、$Y$の空でない開集合$A,B$が存在して、 $$ f(X)\subset A\cup B, \quad A\cap B\cap f(Y) = \emptyset, \quad A\cap f(X)\neq\emptyset, \quad B\cap f(X)\neq\emptyset $$ となることである。これより、 $$ X = f^{-1}(A) \cup f^{-1}(B), \quad f^{-1}(A)\cap f^{-1}(B) = \emptyset $$ が得られる。また、$f$の連続性から$f^{-1}(A)$と$f^{-1}(B)$はそれぞれ$X$の空でない開集合である。 これは$X$が連結であることに矛盾する。 また、連結性に関する挟み撃ちの定理のようなものも成立する。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-08 12:56:17 +0900 JST'>February 8, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;189 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to 連結と局所連結、弧状連結と局所弧状連結について" href="https://yonesuke.github.io/posts/connected/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Unique lifting property
    </h2>
  </header>
  <div class="entry-content">
    <p>Hatcherの&#34;Algebraic Topology&#34;のProposition 1.34でUnique lifting propertyとその証明が与えられているのですが、その証明がわかりにくかったのでここに分かりやすくまとめてみます。 Hatcherが全体的に読みにくいと感じるのは自分だけだろうか。。。
Unique lifting property Unique lifting propertyは被覆空間によってリフトされた連続写像が一点を決めれば一意に定まることを主張しています。
Theorem    [Unique lifting property] 被覆写像$p\colon \tilde{X}\to X$と連続写像$f\colon Y\to X$が与えられている。 また、$Y$は連結であるとする。 $f$のリフト$\tilde{f} _{1},\tilde{f} _{2}\colon Y\to\tilde{X}$がある一点で同じ値を取るとき、$\tilde{f} _{1}=\tilde{f} _{2}$である。 この証明は$Y$が連結であることを巧妙に使います。 証明に用いる概略図を以下に示します。 Proof [Of Theorem 1]: はじめに被覆空間にまたがる性質を見る。 $y\in Y$に対して$U\subset X$を均一な被覆を持つ$f(y)$の開近傍とする。 すなわち、$p^{-1}(U)=\bigcup_{\lambda\in\Lambda}\tilde{U} _ {\lambda}$で$\tilde{U} _ {\lambda}$は互いに素な集合となっていることである。 このとき、$\left.p\right| _ {\tilde{U} _ {\lambda}}\colon\tilde{U} _ {\lambda}\to U$が同相写像となる。 今リフトは連続であるから、$y$のある開近傍$N(y)$が存在して、 $$ \tilde{f} _ {1}(N(y))\subset \tilde{U} _ {1},\quad \tilde{f} _ {2}(N(y))\subset \tilde{U} _ {2} $$ なるような$\tilde{U} _ {1},\tilde{U} _ {2}\in\bigcup_{\lambda\in\Lambda}\tilde{U} _ {\lambda}$が存在する。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-03 15:10:38 +0900 JST'>February 3, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;169 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to Unique lifting property" href="https://yonesuke.github.io/posts/unique_lifting_property/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Hermite多項式の係数
    </h2>
  </header>
  <div class="entry-content">
    <p>Hermite多項式の係数をpythonで求める方法を紹介します。 係数自体は三項間漸化式で求められますが、高次の係数を求めるときには再帰が必要になり計算量が増えてしまいます。 functoolsモジュールのcacheを使うと再帰を高速化できます。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from functools import cache @cache def hermite_coeff(n: int) -&gt; list: &#34;&#34;&#34;Compute the coefficients of the nth Hermite polynomial.&#34;&#34;&#34; if not isinstance(n, int): raise TypeError(&#34;n must be an integer&#34;) if n &lt; 0: raise ValueError(&#34;n must be non-negative&#34;) if n == 0: return [1] elif n == 1: return [0, 2] else: return [- 2 * (n - 1) * hermite_coeff(n - 2)[0]]\ &#43; [2 * hermite_coeff(n - 1)[i] - 2 * (n - 1) * hermite_coeff(n - 2)[i &#43; 1] for i in range(n - 2)]\ &#43; [2 * hermite_coeff(n - 1)[n - 2], 2 * hermite_coeff(n - 1)[n - 1]] hermite_coeff(n)はn次のHermite多項式の係数を返します。 hermite_coeff(n)はnが整数でないとき、nが負のときにTypeErrorとValueErrorを返します。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-01-31 19:06:00 +0900 JST'>January 31, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;257 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to Hermite多項式の係数" href="https://yonesuke.github.io/posts/hermite_coeff/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Random Fourier Features
    </h2>
  </header>
  <div class="entry-content">
    <p>カーネル法によるリッジ回帰は表現力が高いことが知られており、またその数学的背景の豊かさから多くの研究がなされてきました。 しかし、$n$個のデータ数に対して推論に$\mathcal{O}(n^{3})$の計算量が必要とされるため、計算量を低減させる方法を検討することは非常に重要です。 ここでは、Random Fourier Features 1と呼ばれる方法を紹介します。 実装も行ったがGistにも公開している。
Random Fourier Features Random Fourier Featuresはカーネル関数$k(x,y)\colon\mathbb{R}^{d}\times\mathbb{R}^{d}\to\mathbb{R}$が$x-y$の関数$\phi(x-y)$で表現できる場合に、それをランダムな基底で近似する手法である。キモとなるのはBochnerの定理である。
Theorem    [Bochnerの定理] $k(x,y)=\phi(x-y)$が連続な正定値カーネルであるための必要十分条件は$\mathbb{R}^{d}$上の有限非負Borel測度$\mu$があって、 $$ k(x,y)=\int_{\mathbb{R}^{d}}e^{i\omega^{\top}(x-y)}\mathrm{d}\mu(\omega) $$ で表されることである。 適当にスケールすれば$\mu$は確率になり、(存在すれば)$\mathrm{d}\mu(\omega)=p(\omega)\mathrm{d}\omega$と書くことが出来る。 このとき、$k$の値域は実数であるので、 $$ k(x,y)=\mathbb{E}_ {\omega}[\cos(\omega^{\top}(x-y))] $$ 実はこれは$b$を$[0,2\pi)$上の一様乱数として、 $$ 2\mathbb{E}_ {\omega,b}[\cos(\omega^{\top}x&#43;b)\cos(\omega^{\top}y&#43;b)] $$ と一致することがわかる。(加法定理を用いよ)
Proposition    [Random Fourier Features] カーネル関数$k(x,y)$が$x-y$の関数で与えられるとき、 $$ k(x,y)=2\mathbb{E}_ {\omega,b}[\cos(\omega^{\top}x&#43;b)\cos(\omega^{\top}y&#43;b)] $$ が成立する。ここで、$\omega$は$k$の確率に従い、$b$は$[0,2\pi)$上の一様分布に従う。 この性質を用いてカーネル関数を近似することを考える。$\omega_{i},b_{i}$をそれぞれの分布に従う乱数として$m$個発生させ、関数$z_{i}(x)=\sqrt{2/m}\cos(\omega_{i}^{\top}x&#43;b_{i})$を構成したとき、 $$ \sum_{i=1}^{m}z_{i}(x)z_{i}(y)\to k(x,y) $$ が$m\to\infty$の極限で大数の法則により収束していく。
Kernel Ridge Regression Random Fourier Featuresを用いてカーネル関数を表現することによってカーネルリッジ回帰の計算量が低減される。
データ$\mathcal{D}=\{(x_{i},y_{i})\}_ {i=1}^{n}$が与えられる場合を考える。入力$x_{i}$を特徴写像$\Phi$で写し、写した先の空間$H$でリッジ回帰をする。 損失関数は $$ L=\sum_{i=1}^{n}[y_{i}-f(x_{i})]^{2}&#43;\lambda||f||^{2}_ {H} $$ となり、これを最小化する$f\in H$を探す。$\lambda||f||^{2}_ {H}$は正則化の項である。 Representation定理により$f$は$\Phi(x_{i})$で展開されることがわかり、色々計算すると損失関数を最小化する$\hat{f}$は $$ \hat{f}(x)=\sum_{i=1}^{n}\hat{\alpha}_{i}k(x_{i},x) $$ となることがわかる。ここで、$\hat{\alpha}=(K&#43;\lambda I_{n})^{-1}y,[K]_{ij}=k(x_{i},x_{j})$である。 $\alpha$の計算に逆行列が含まれるため$\mathcal{O}(n^{3})$の計算量が必要となってしまう。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-01-06 23:34:02 +0900 JST'>January 6, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;766 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to Random Fourier Features" href="https://yonesuke.github.io/posts/random_fourier_feature/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://yonesuke.github.io/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://yonesuke.github.io">Ryosuke Yoneda</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
