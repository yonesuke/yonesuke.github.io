<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Ryosuke Yoneda</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Ryosuke Yoneda">
<meta name="author" content="">
<link rel="canonical" href="https://yonesuke.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yonesuke.github.io/favicon_io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yonesuke.github.io/favicon_io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yonesuke.github.io/favicon_io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yonesuke.github.io/favicon_io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yonesuke.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://yonesuke.github.io/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://yonesuke.github.io/css/theoremproof.css">
<meta property="og:title" content="Posts" />
<meta property="og:description" content="Ryosuke Yoneda&#39;s Homepage" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yonesuke.github.io/posts/" /><meta property="og:image" content="https://yonesuke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/><meta property="og:site_name" content="Ryosuke Yoneda" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://yonesuke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/>

<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="Ryosuke Yoneda&#39;s Homepage"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://yonesuke.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yonesuke.github.io" accesskey="h" title="Ryosuke Yoneda&#39;s Homepage (Alt + H)">
                <img src="https://yonesuke.github.io/favicon_io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Ryosuke Yoneda&#39;s Homepage</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yonesuke.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://yonesuke.github.io/research" title="Research">
                    <span>Research</span>
                </a>
            </li>
            <li>
                <a href="https://yonesuke.github.io/teaching" title="Teaching">
                    <span>Teaching</span>
                </a>
            </li>
            <li>
                <a href="https://yonesuke.github.io/posts" title="Posts">
                    <span class="active">Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://yonesuke.github.io">Home</a></div>
  <h1>
    Posts
    <a href="index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>単連結な被覆空間の存在<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>ホモロジーゼミの基本群パートの一つの山場である、被覆空間の分類定理がやってきました。 この定理を示すためには、単連結な被覆空間の存在証明が必要になります。
Theorem   弧状連結かつ局所弧状連結な位相空間$X,\tilde{X}$で、$\tilde{X}$は$X$の被覆空間とする。$\tilde{X}$が単連結になるための必要十分条件は$X$が半局所単連結であることである。 準備 はじめに、この証明に必要ないくつかの定義・定理を示します。
Definition    [半局所単連結] 位相空間$X$が半局所単連結であるとは、任意の$x\in X$に対して$x$の開近傍$U$が存在して、包含写像$i\colon U\hookrightarrow X$から誘導される基本群の準同型写像$i_{\ast}\colon \pi_{1}(U,x)\hookrightarrow \pi_{1}(X,x)$が自明になることである。 Theorem   $O$を$S$における1つの位相とする。$M$が$O$の基底であることと、任意の$A\in O$と任意の$x\in A$に対して、 $$ x\in W,\quad W\subset A $$ となる$W\in M$が存在することは同値である。 Theorem   空でない集合$S$について、$B(S)$の部分集合$M$が$O(M)$の基底であることは次の2つと同値である。
任意の$x\in S$に対してある$W\in M$が存在して$x\in W$となる。 任意の$W_{1},W_{2}\in M$で$W_{1}\cap W_{2}\ne \emptyset$であるとき、任意の$x\in W_{1}\cap W_{2}$に対して、ある$W\subset W_{1} \cap W_{2}$が存在して$x\in W$なる$W\in M$が存在する。 証明は位相の基底を参照してください。
証明 はじめに、必要条件を示します。 すなわち、$X$が単連結な被覆空間を持つとき、$X$が半局所単連結であることを示します。
Proof: $p\colon \tilde{X}\to X$が被覆空間で$\tilde{X}$が単連結とする。 任意の$x\in X$とその開近傍$U\subset X$に対して、そのリフト$\tilde{U}\subset \tilde{X}$が存在して、$p| _ {\tilde{U}}\colon \tilde{U}\to U$が同相写像となる。 このとき、$U$内の$x_{0}$を基点とする任意のループ$\gamma$に対して、対応する$\tilde{U}$内の$\tilde{\gamma}$が存在する。$\tilde{X}$は単連結であるから$\tilde{\gamma}$は$\tilde{x}$の基点による定数関数にホモトピックになる。対応する$\gamma$も$x_{0}$の基点による定数関数にホモトピックになる。 これより$X$は半局所単連結である。 次に、十分条件を示します。 すなわち、$X$が半局所単連結であるとき、$X$が単連結な被覆空間$\tilde{X}$を持つことを示します。 証明は具体的に$\tilde{X}$を構成し、それが単連結であることを示すことで行います。
Proof: 弧状連結、局所弧状連結、半局所単連結な位相空間$X$で$x_{0}$を基点とする。 このとき、単連結な被覆空間を $$ \begin{aligned} \tilde{X} &amp;= \left\{[\gamma] \mathrel{}\middle|\mathrel{} \gamma\colon \textrm{path in } X \textrm{ starting at } x_{0}\right\} \\ p &amp;\colon \tilde{X}\to X;\quad[\gamma] \mapsto \gamma(1) \end{aligned} $$ で定める。$[\gamma]$は基点と終点を定めたときのpathをホモトピックなもので割った同値類である。 このように構成された空間が実際に単連結な被覆空間であることを示す。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-17 22:17:24 +0900 JST'>February 17, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;228 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to 単連結な被覆空間の存在" href="https://yonesuke.github.io/posts/existence_of_simply_connected_covering_space/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>位相の基底
    </h2>
  </header>
  <div class="entry-content">
    <p>ホモロジーゼミの中で位相の基底に関する議論が出てきたのでそれについてまとめます。 この記事は大部分が松坂の集合位相入門によっています。
定義 位相の生成 考える空間を$S$とし、その部分集合全体を集めた集合を$B(S)$で定めます。 $B(S)$の任意の部分集合$M$に対して$O(M)$を$O\supset M$であるような任意の位相に対する下限(すなわちそのような位相たちの共通部分)で定めます。
$O(M)$が具体的にどのような$S$の部分集合で表現されるかを決めるのが次の定理です。
Theorem   $M$を$B(S)$の任意の部分集合とする。このとき、 $$ O(M)=\left\{\bigcup_{\lambda\in\Lambda} B_{\lambda} \mathrel{}\middle|\mathrel{} B_{\lambda}\in M_{0}\right\} $$ である。ただし、 $$ M_{0}=\left\{ \bigcap_{i\in I} A_{i} \mathrel{}\middle|\mathrel{} A_{i}\in M, \# I&lt;\infty\right\} $$ である。 ここで、$\#I=0$であれば$\bigcap_{i\in I}A_{i}=S$で定めます。積の単位元を全体にしているようなものです。
位相の基底 Definition    [位相の基底] $M$が位相$O$の部分集合で$O$の任意の元$A$が $$ A=\bigcup_{\lambda\in\Lambda} W_{\lambda},\quad W_{\lambda}\in M $$ と表されるとき、$M$は$O$の基底であるという。 すなわち、任意の開集合が$M$の元を用いて展開できる、という意味で基底になっている、ということです。
性質 Theorem   $O$を$S$における1つの位相とする。$M$が$O$の基底であることと、任意の$A\in O$と任意の$x\in A$に対して、 $$ x\in W,\quad W\subset A $$ となる$W\in M$が存在することは同値である。 Proof: $M$が$O$の基底であるとき、$A$を$O$の任意の元とすると、基底の定義からある$W_{\lambda}\in M$が存在して、 $$ A=\bigcup_{\lambda\in\Lambda} W_{\lambda} $$ が成り立つ。このとき、$x\in A$なので、ある$\lambda^{\ast}\in \Lambda$が存在して$x\in W_{\lambda^{\ast}}$となるので示される。 逆に任意の$A\in O$と任意の$x\in A$に対して$x\in W_{x},W_{x}\subset A$なる$W_{x}\in M$が存在するとき、 $$ A=\bigcup_{x\in A}\{x\}=\bigcup_{x\in A} W_{x} $$ となるのでたしかに$M$は$O$の基底である。 Theorem   空でない集合$S$について、$B(S)$の部分集合$M$が$O(M)$の基底であることは次の2つと同値である。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-17 14:32:22 +0900 JST'>February 17, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;156 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to 位相の基底" href="https://yonesuke.github.io/posts/topology_basis/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>連結と局所連結、弧状連結と局所弧状連結について<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>ホモロジーゼミの中で連結性に関する議論が何度も出てくるのでその違いについていくらかまとめておきます。
定義 はじめに連結の定義を述べる。直感的に想像するような&#34;連結&#34;からかけ離れているように思われる。
Definition    [連結] 位相空間$X$が連結であるとは、同時に開かつ閉になる部分集合が$X$自身と空集合以外に存在しないことをいう。 連結であることの定義は若干直感的に理解するのが難しい。連結でない空間の特徴づけの一つにわかりやすいものがある。これは、“空でない2つの互いに素な開集合$A,B\subset X$によって$X=A\cup B$とかける&#34;ことによって連結でない空間を定義するものである。実際この性質を用いることもある。 位相空間$X$の部分集合$M$が連結であるとは、$M$に導入される相対位相に対して$M$が連結であることとして定義する。$M$が連結でないことは$X$の開集合を用いて上と同様に特徴づけられる。すなわち、空でない2つの開集合$A,B$が存在して、 $$ M\subset A\cup B, \quad A\cap B\cap M=\emptyset, \quad A\cap M\neq\emptyset, \quad B\cap M\neq\emptyset $$ となることである。 局所的に連結な空間を局所連結と呼ぶ。
Definition    [局所連結] 位相空間$X$の任意の$x\in X$の任意の開近傍$V$に対して、$x\in U\subset V$なる連結開集合$U$が存在するとき、$X$は局所連結であるという。 局所連結は局所的なものを見るので連結であれば局所連結であるように思われるがそうではない。これは後で反例を見る。
次に弧状連結の定義を見る。むしろ弧状連結のほうが&#34;連結&#34;らしさを感じる。
Definition    [弧状連結] 位相空間$X$が弧状連結であるとは、任意の2点$x,y\in X$に対してある連続写像$f\colon [0,1]\to X$が存在して、$f(0)=x,f(1)=y$が成り立つことをいう。 定義内に登場する$f$は$x$と$y$を結ぶ弧(path)である。 位相空間$X$の部分集合$M$が弧状連結であるとは、$M$に導入される相対位相に対して$M$が弧状連結であることとして定義する。 局所的に弧状連結な空間を局所弧状連結と呼ぶ。
Definition    [局所弧状連結] 位相空間$X$の任意の$x\in X$の任意の開近傍$V$に対して、$x\in U\subset V$なる弧状連結開集合$U$が存在するとき、$X$は局所弧状連結であるという。 局所弧状連結についても弧状連結と直接の関係がない。すなわち、弧状連結であれば局所弧状連結であるとは限らない。
性質 連結性に関する性質の中でも一番重要なのは、“連続写像を通して連結性が写る&#34;ことであろう。
Theorem   位相空間$X$は連結で連続写像$f\colon X\to Y$を通して位相空間$Y$へ写る。このとき、$f(X)$は$Y$の連結部分集合である。 Proof: $f(X)$が連結でないとすると、$Y$の空でない開集合$A,B$が存在して、 $$ f(X)\subset A\cup B, \quad A\cap B\cap f(Y) = \emptyset, \quad A\cap f(X)\neq\emptyset, \quad B\cap f(X)\neq\emptyset $$ となることである。これより、 $$ X = f^{-1}(A) \cup f^{-1}(B), \quad f^{-1}(A)\cap f^{-1}(B) = \emptyset $$ が得られる。また、$f$の連続性から$f^{-1}(A)$と$f^{-1}(B)$はそれぞれ$X$の空でない開集合である。 これは$X$が連結であることに矛盾する。 また、連結性に関する挟み撃ちの定理のようなものも成立する。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-08 12:56:17 +0900 JST'>February 8, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;189 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to 連結と局所連結、弧状連結と局所弧状連結について" href="https://yonesuke.github.io/posts/connected/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Unique lifting property
    </h2>
  </header>
  <div class="entry-content">
    <p>Hatcherの&#34;Algebraic Topology&#34;のProposition 1.34でUnique lifting propertyとその証明が与えられているのですが、その証明がわかりにくかったのでここに分かりやすくまとめてみます。 Hatcherが全体的に読みにくいと感じるのは自分だけだろうか。。。
Unique lifting property Unique lifting propertyは被覆空間によってリフトされた連続写像が一点を決めれば一意に定まることを主張しています。
Theorem    [Unique lifting property] 被覆写像$p\colon \tilde{X}\to X$と連続写像$f\colon Y\to X$が与えられている。 また、$Y$は連結であるとする。 $f$のリフト$\tilde{f} _{1},\tilde{f} _{2}\colon Y\to\tilde{X}$がある一点で同じ値を取るとき、$\tilde{f} _{1}=\tilde{f} _{2}$である。 この証明は$Y$が連結であることを巧妙に使います。 証明に用いる概略図を以下に示します。 Proof [Of Theorem 1]: はじめに被覆空間にまたがる性質を見る。 $y\in Y$に対して$U\subset X$を均一な被覆を持つ$f(y)$の開近傍とする。 すなわち、$p^{-1}(U)=\bigcup_{\lambda\in\Lambda}\tilde{U} _ {\lambda}$で$\tilde{U} _ {\lambda}$は互いに素な集合となっていることである。 このとき、$\left.p\right| _ {\tilde{U} _ {\lambda}}\colon\tilde{U} _ {\lambda}\to U$が同相写像となる。 今リフトは連続であるから、$y$のある開近傍$N(y)$が存在して、 $$ \tilde{f} _ {1}(N(y))\subset \tilde{U} _ {1},\quad \tilde{f} _ {2}(N(y))\subset \tilde{U} _ {2} $$ なるような$\tilde{U} _ {1},\tilde{U} _ {2}\in\bigcup_{\lambda\in\Lambda}\tilde{U} _ {\lambda}$が存在する。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-03 15:10:38 +0900 JST'>February 3, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;169 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to Unique lifting property" href="https://yonesuke.github.io/posts/unique_lifting_property/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Hermite多項式の係数
    </h2>
  </header>
  <div class="entry-content">
    <p>Hermite多項式の係数をpythonで求める方法を紹介します。 係数自体は三項間漸化式で求められますが、高次の係数を求めるときには再帰が必要になり計算量が増えてしまいます。 functoolsモジュールのcacheを使うと再帰を高速化できます。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from functools import cache @cache def hermite_coeff(n: int) -&gt; list: &#34;&#34;&#34;Compute the coefficients of the nth Hermite polynomial.&#34;&#34;&#34; if not isinstance(n, int): raise TypeError(&#34;n must be an integer&#34;) if n &lt; 0: raise ValueError(&#34;n must be non-negative&#34;) if n == 0: return [1] elif n == 1: return [0, 2] else: return [- 2 * (n - 1) * hermite_coeff(n - 2)[0]]\ &#43; [2 * hermite_coeff(n - 1)[i] - 2 * (n - 1) * hermite_coeff(n - 2)[i &#43; 1] for i in range(n - 2)]\ &#43; [2 * hermite_coeff(n - 1)[n - 2], 2 * hermite_coeff(n - 1)[n - 1]] hermite_coeff(n)はn次のHermite多項式の係数を返します。 hermite_coeff(n)はnが整数でないとき、nが負のときにTypeErrorとValueErrorを返します。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-01-31 19:06:00 +0900 JST'>January 31, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;257 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to Hermite多項式の係数" href="https://yonesuke.github.io/posts/hermite_coeff/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Random Fourier Features
    </h2>
  </header>
  <div class="entry-content">
    <p>カーネル法によるリッジ回帰は表現力が高いことが知られており、またその数学的背景の豊かさから多くの研究がなされてきました。 しかし、$n$個のデータ数に対して推論に$\mathcal{O}(n^{3})$の計算量が必要とされるため、計算量を低減させる方法を検討することは非常に重要です。 ここでは、Random Fourier Features 1と呼ばれる方法を紹介します。 実装も行ったがGistにも公開している。
Random Fourier Features Random Fourier Featuresはカーネル関数$k(x,y)\colon\mathbb{R}^{d}\times\mathbb{R}^{d}\to\mathbb{R}$が$x-y$の関数$\phi(x-y)$で表現できる場合に、それをランダムな基底で近似する手法である。キモとなるのはBochnerの定理である。
Theorem    [Bochnerの定理] $k(x,y)=\phi(x-y)$が連続な正定値カーネルであるための必要十分条件は$\mathbb{R}^{d}$上の有限非負Borel測度$\mu$があって、 $$ k(x,y)=\int_{\mathbb{R}^{d}}e^{i\omega^{\top}(x-y)}\mathrm{d}\mu(\omega) $$ で表されることである。 適当にスケールすれば$\mu$は確率になり、(存在すれば)$\mathrm{d}\mu(\omega)=p(\omega)\mathrm{d}\omega$と書くことが出来る。 このとき、$k$の値域は実数であるので、 $$ k(x,y)=\mathbb{E}_ {\omega}[\cos(\omega^{\top}(x-y))] $$ 実はこれは$b$を$[0,2\pi)$上の一様乱数として、 $$ 2\mathbb{E}_ {\omega,b}[\cos(\omega^{\top}x&#43;b)\cos(\omega^{\top}y&#43;b)] $$ と一致することがわかる。(加法定理を用いよ)
Proposition    [Random Fourier Features] カーネル関数$k(x,y)$が$x-y$の関数で与えられるとき、 $$ k(x,y)=2\mathbb{E}_ {\omega,b}[\cos(\omega^{\top}x&#43;b)\cos(\omega^{\top}y&#43;b)] $$ が成立する。ここで、$\omega$は$k$の確率に従い、$b$は$[0,2\pi)$上の一様分布に従う。 この性質を用いてカーネル関数を近似することを考える。$\omega_{i},b_{i}$をそれぞれの分布に従う乱数として$m$個発生させ、関数$z_{i}(x)=\sqrt{2/m}\cos(\omega_{i}^{\top}x&#43;b_{i})$を構成したとき、 $$ \sum_{i=1}^{m}z_{i}(x)z_{i}(y)\to k(x,y) $$ が$m\to\infty$の極限で大数の法則により収束していく。
Kernel Ridge Regression Random Fourier Featuresを用いてカーネル関数を表現することによってカーネルリッジ回帰の計算量が低減される。
データ$\mathcal{D}=\{(x_{i},y_{i})\}_ {i=1}^{n}$が与えられる場合を考える。入力$x_{i}$を特徴写像$\Phi$で写し、写した先の空間$H$でリッジ回帰をする。 損失関数は $$ L=\sum_{i=1}^{n}[y_{i}-f(x_{i})]^{2}&#43;\lambda||f||^{2}_ {H} $$ となり、これを最小化する$f\in H$を探す。$\lambda||f||^{2}_ {H}$は正則化の項である。 Representation定理により$f$は$\Phi(x_{i})$で展開されることがわかり、色々計算すると損失関数を最小化する$\hat{f}$は $$ \hat{f}(x)=\sum_{i=1}^{n}\hat{\alpha}_{i}k(x_{i},x) $$ となることがわかる。ここで、$\hat{\alpha}=(K&#43;\lambda I_{n})^{-1}y,[K]_{ij}=k(x_{i},x_{j})$である。 $\alpha$の計算に逆行列が含まれるため$\mathcal{O}(n^{3})$の計算量が必要となってしまう。...</p>
  </div>
  <footer class="entry-footer"><span title='2023-01-06 23:34:02 +0900 JST'>January 6, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;766 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to Random Fourier Features" href="https://yonesuke.github.io/posts/random_fourier_feature/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>AUTOのインストール方法
    </h2>
  </header>
  <div class="entry-content">
    <p>AUTOはODE(常微分方程式)の分岐解析を扱うソフトウェアで、1980年に開発されて以来力学系界隈で使われてきました。 現在はGitHubにてコードが公開されて細々と(?)開発が続けられています。
https://github.com/auto-07p/auto-07p AUTOは便利ではあるのですが、そのインストール方法がプログラム初心者には少し難しいことがあるそうなのでその流れを少しまとめてみました。 以下では基本的にMac OSでインストールする方法を述べますが、WindowsやLinuxでも同様だと思います。 また、最低限のターミナルでの操作は出来るものとしておきます。
インストール方法 はじめにGitHubからコードをダウンロードする必要があります。これには、リポジトリをcloneする方法とリリースからダウンロードをする方法があります。 cloneという言葉の意味がわからなければリリースからダウンロードする方が良いかもしれません。
GitHubからAUTOのリポジトリをcloneする場合は次のコマンドを打ち込みます。 1 git clone git@github.com:auto-07p/auto-07p.git 次にこのフォルダをホーム直下で~/.auto-07pという名前で移動させましょう。 1 mv auto-07p ~/.auto-07p この場所が嫌ならば他の場所に他の名前で移動させてもらっても構いません。その場合は後で編集するauto.env.shも適切に変えてください。 GitHub内のリリースページ内にある最新のリリースからSource code (zip)をダウンロードしてください。記事作成時点ではバージョン0.9.3が最新でした。例えばDownloadsフォルダ内にzipファイルが格納されたとしましょう。このフォルダを開いてzipファイルを展開してください。同一フォルダ内でauto-07p-0.9.3というフォルダが作られるはずです(後ろの数字はバージョンを表すので変動する可能性はあります)。次にターミナルを開いて次のコマンドを打ち込んでください。 1 mv ~/Downloads/auto-07p-0.9.3 ~/.auto-07p 上に同じですが、この場所が嫌ならば他の場所に他の名前で移動させてもらっても構いません。 このフォルダ内に移動しておきます。
1 cd ~/.auto-07p フォルダ内で./configureを実行した上でmakeを行います。
1 2 ./configure make 何も問題がなければこのmakeは成功しますが、うまくAUTOが起動出来ない場合はこのmakeで失敗している可能性が高いです。エラーが出ていないかはよく見ておいてください。
あとはAUTOの設定ファイルをシェルに読み込ませるだけですが、GitHubからcloneしたファイルに間違いがあるので修正する(間違っているというか、リリースされているもののフォルダ構成がGitHubのフォルダ構成と微妙に違うだけ、ではあります)。~/.auto-07p/cmds/auto.env.shの5行目を次のように編集してください。
1 2 -AUTO_DIR=$HOME/auto/07p &#43;AUTO_DIR=$HOME/.auto-07p このとき~/.auto-07p以外にフォルダを設置している場合はそのようにAUTO_DIRを設定しておいてください。 最終的に~/.auto-07p/cmds/auto.env.shは次のようになります。
1 2 3 4 5 6 7 8 9 10 11 12 13 # # This file has to be sourced before activating AUTO if you are using # a &#39;sh&#39; compatible shell, such as sh, bash, ksh, or ash....</p>
  </div>
  <footer class="entry-footer"><span title='2022-11-20 00:21:47 +0900 JST'>November 20, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;124 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to AUTOのインストール方法" href="https://yonesuke.github.io/posts/auto_install/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Ising model on a Bethe lattice<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>Baxterの本にベーテ格子上のイジングモデルの話があって面白かったのでまとめてみます。臨界点と臨界指数を求めるところまで書いてみます。
Bethe lattice ベーテ格子は無限サイズのグラフの一つで、統計力学において厳密に解ける模型としてしばしば登場するものです。 具体的には次のように構成します。
中心の点からスタートとして$q$個の点と枝を繋ぐ。中心の点を$0$番目の殻、それと繋がる点を$1$番目の殻に属すると呼ぶ。 $r$番目の殻まで構成したとき、その殻に属するそれぞれの点から$q-1$個の点と枝を繋ぎ、この点を$r&#43;1$番目の殻とする。 この操作を無限に繰り返すことでベーテ格子が構成されます。例えば$q=$5として3番目の殻までプロットしたものは次のようになります。
Ising model 統計力学の細かい話はここでは述べません。定義だけさらっとまとめていきます。イジングモデルのエネルギーは、 $$ H(\bm{\sigma})=-J\sum_{\langle i,j\rangle}\sigma_{i}\sigma_{j}-H\sum_{i}\sigma_{i} $$ で与えられ、$\bm{\sigma}$の確率分布は $$ P(\bm{\sigma})=\exp(-H(\bm{\sigma})/k_{B}T)=\exp\left[K\sum_{\langle i,j\rangle}\sigma_{i}\sigma_{j}&#43;h\sum_{i}\sigma_{i}\right] $$ になります。$\bm{\sigma}$の各要素は$\pm1$の値を取ります。 $\langle i,j\rangle$はベーテ格子上の隣接する点を集めたものです。 $k_{B}$はボルツマン定数であり、$K=J/k_{B}T,h=H/k_{B}T$と置いています。 この分布は規格化されていません。規格化定数が分配関数でこれは$Z=\sum_{\bm{\sigma}}P(\bm{\sigma})$になります。 適当な物理量は確率分布をもとに計算されます。例えば中心の磁化を$\sigma_{0}$と置くとその値は $$ M=\langle\sigma_{0}\rangle=\frac{1}{Z}\sum_{\bm{\sigma}}\sigma_{0}P(\bm{\sigma}) $$ で与えられます。次のセクションで$M$の値を実際に計算していきます。
Recurrence relation ベーテ格子の対称性から中心の点はは$q$個の同一の部分木に分けられます。$j$番目の部分木の点集合を$s^{(j)}$と置くと確率分布は、 $$ P(\bm{\sigma})=\exp(h\sigma_{0})\prod_{j=1}^{q}Q_{n}(\sigma_{0}\mid s^{(j)}) $$ で書けます。ここで、 $$ Q_{n}(\sigma_{0}\mid s) = \exp\left[K\sum_{\langle i,j\rangle}s_{i}s_{j}&#43;Ks_{1}\sigma_{0}&#43;h\sum_{i}s_{i}\right] $$ は$\sigma_{0}$と木$s$との接続が寄与する項を表します。そのため和を取る項はすべて$s$内のものになります。 添字$n$はこの段階では$n$番目の殻まで打ち切ったベーテ格子を考えていることから来るものです。このあとで$n\to\infty$の極限を考えます。
これをもとに中心の磁化$M$を計算します。$Q_{n}$を部分木上で和を取ったものを$g_{n}$と置くことにします。すなわち、 $$ g_{n}(\sigma_{0})=\sum_{s}Q_{n}(\sigma_{0}\mid s) $$ です。各部分木上で$g_{n}$の値が一致することを用いると、 $$ \begin{align*} M=&amp;Z^{-1}\sum_{\sigma_{0}}\sigma_{0}\exp(h\sigma_{0})[g_{n}(\sigma_{0})]^{q}=Z^{-1}\left(e^{h}[g_{n}(&#43;1)]^{q}-e^{-h}[g_{n}(-1)]^{q}\right)\\ Z=&amp;\sum_{\sigma_{0}}\exp(h\sigma_{0})[g_{n}(\sigma_{0})]^{q}=e^{h}[g_{n}(&#43;1)]^{q}&#43;e^{-h}[g_{n}(-1)]^{q} \end{align*} $$ になります。ここで、$x_{n}=g_{n}(-1)/g_{n}(&#43;1)$と置くと、 $$ M=\frac{e^{h}-e^{-h}x_{n}}{e^{h}&#43;e^{-h}x_{n}} $$ が得られます。
$x_{n}$は$n$に依存するので、$n$に関する漸化式を求めてみましょう。$Q_{n}$を構成する部分木$s$はそれ自身$q-1$個の部分木を含みます。なので、$Q_{n}$はさらなる分解が期待されます。 $$ Q_{n}(\sigma_{0}\mid s)=\exp(K\sigma_{0}s_{1}&#43;hs_{1})\prod_{j=1}^{q-1}Q_{n-1}(s_{1}\mid t^{(j)}) $$ ここで、$s_{1}$は部分木$s$の根であり、$t^{(j)}$は$s_{1}$に接続する$j$番目の部分木になります。 この式を部分木$s$上で和を取って見ましょう。特に、右辺は$s_{1}$と$t^{(j)}$上の和に分解してみると、 $$ \begin{align*} g_{n}(\sigma_{0})=&amp;\sum_{s_{1}}\exp(K\sigma_{0}s_{1}&#43;hs_{1})[g_{n-1}(s_{1})]^{q-1}\\ =&amp;\exp(K\sigma_{0}&#43;h)[g_{n-1}(&#43;1)]^{q-1}&#43;\exp(-K\sigma_{0}-h)[g_{n-1}(-1)]^{q-1} \end{align*} $$ になるので、$x_{n}$については $$ \begin{align*} x_{n}=&amp;\frac{g_{n}(-1)}{g_{n}(&#43;1)}\\ =&amp;\frac{\exp(-K&#43;h)[g_{n-1}(&#43;1)]^{q-1}&#43;\exp(K-h)[g_{n-1}(-1)]^{q-1}}{\exp(K&#43;h)[g_{n-1}(&#43;1)]^{q-1}&#43;\exp(-K-h)[g_{n-1}(-1)]^{q-1}}\\ =&amp;\frac{e^{-K&#43;h}&#43;e^{K-h}x_{n-1}^{q-1}}{e^{K&#43;h}&#43;e^{-K-h}x_{n-1}^{q-1}} \end{align*} $$ が得られます。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-01 16:15:49 +0900 JST'>October 1, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;109 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to Ising model on a Bethe lattice" href="https://yonesuke.github.io/posts/bethe_ising/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>はめ込みと埋め込み
    </h2>
  </header>
  <div class="entry-content">
    <p>松本『多様体の基礎』とTu『トゥー多様体』を読みながらはめ込みと埋め込みについて書いてあったことをまとめます。
はめ込みと埋め込み Definition    [はめ込み] $f\colon M\to N$がはめ込みであるとは、任意の$p\in M$における$f$の微分$(df) _ {p}\colon T_{p} M\to T_{f(p)} N$が単射になることである。 ユークリッド空間のもとでのはめ込みは$\mathbb{R}^{m}$からより高い次元$\mathbb{R}^{m}$への包含写像 $$ i\colon\mathbb{R}^{m}\to\mathbb{R}^{n};(x_{1},\dots,x_{m})\mapsto(x_{1},\dots,x_{n},0,\dots,0) $$ となります。この写像は局所的であり、これを多様体へと拡張したものが次のはめ込み定理になります。
Theorem    [はめ込み定理] $f\colon M\to N$がはめ込みであるとする。任意の点$p\in M$に対してある座標近傍$(U;\phi)$と$f(p)\in N$に対するある座標近傍$(V;\psi)$があって、$\phi(p)$のある近傍で、 $$ (\psi\circ f\circ \phi^{-1})(r_{1},\dots,r_{m})=(r_{1},\dots,r_{n},0,\dots,0) $$ なるものが存在する。 この意味ですべてのはめ込みは局所的には包含写像になることがわかります。しかし、この場合$f(M)$は後で見る部分多様体にはならないことがあります。この場合$f$に次の条件を与えた埋め込みを考えます。
Definition    [埋め込み] $f\colon M\to N$が埋め込みであるとは、$f$がはめ込みであってかつ、$f(M)$に$N$の相対位相を入れたときに$f\colon M\to f(M)$が同相写像となることである。 ただしはめ込み定理があるので、はめ込みは局所的には埋め込みになります。
Proposition   $C^{r}$級はめ込みは局所的には$C^{r}$級埋め込みである。すなわり、任意の点$p\in M$に対して, $p$のある開近傍$U$が存在して、$f|_{U}\colon U\to N$は埋め込みである。 部分多様体 Definition    [正則部分多様体] $n$次元$C^{r}$級多様体$N$の部分集合$S$が$k$次元の $C^{r}$級正則部分多様体であるとは、任意の点$p\in S$に対して、ある座標近傍$(U;x_{1},\dots,x_{n})$が存在して、 $$ U\cap S=\{(x_{1},\dots,x_{n})\in U\mid x_{k&#43;1}=\cdots=x_{n}=0\} $$ が成り立つことである。 『トゥー多様体』ではこのような$N$のチャートを$S$に適合するチャートと呼びます。
Proposition   $n$次元$C^{r}$級多様体$N$の$k$次元$C^{r}$級正則部分多様体$S$はそれ自身$k$次元$C^{r}$級多様体である。 Proof [Of Proposition]: $(U;\phi)=(U;x_{1},\dots,x_{n}),(V,\psi)=(V;y_{1},\dots,y_{n})$を適合するチャートとし、$U\cap V\ne\emptyset$とする。このとき、$p\in U\cap V\cap S$に対して $$ \phi(p)=(x_{1}(p),\dots,x_{k}(p),0,\dots,0),\psi(p)=(y_{1}(p),\dots,y_{k}(p),0,\dots,0) $$ である。そこで、$\phi,\psi$の出力を$k$次元目までのところに制限したものを$\phi_{S},\psi_{S}$と書くことにすると、$\psi_{S}\circ\phi_{S}^{-1},\phi_{S}\circ\psi_{S}^{-1}$はそれぞれ$C^{r}$級の座標変換関数になる。 よって適合するチャートから構成した族$\{(U\cap S;\phi_{S})\}$は$S$の$C^{r}$級のアトラスになる。よって$S$は$k$次元$C^{r}$級多様体である。 次の2つの定理によって多様体の埋め込みと正則部分多様体は同じものとみなすことができます。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-08-30 17:18:33 +0900 JST'>August 30, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;96 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to はめ込みと埋め込み" href="https://yonesuke.github.io/posts/immersion-embedding/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>JAXで蔵本モデル<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import jax.numpy as jnp from jax import random, jit from jax.lax import fori_loop class AutonomousDiffEq: def __init__(self, n_dim: int): self.n_dim = n_dim def forward(self, state): return NotImplementedError def runge_kutta(self, state, dt): k1 = self.forward(state) k2 = self.forward(state &#43; 0.5 * dt * k1) k3 = self....</p>
  </div>
  <footer class="entry-footer"><span title='2022-08-26 14:46:14 +0900 JST'>August 26, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;157 words&nbsp;·&nbsp;Ryosuke Yoneda</footer>
  <a class="entry-link" aria-label="post link to JAXで蔵本モデル" href="https://yonesuke.github.io/posts/jax-kuramoto/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://yonesuke.github.io/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://yonesuke.github.io">Ryosuke Yoneda</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
